<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <!--<link rel="stylesheet" href="css/base.css" />-->
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="VoiroGokko.js"></script>
    <script src="Canvases.js"></script>
    <script>
        var canvases = new Canvases;
        var userId = "123456789";
        var userStage  = {};
        var _tachieLoader = {};
        var charaChange = false;
        var maxChildIndex = 10;
        var tachieBaseLayer = 2;
        var tachieEmotionLayer = 4;
        var tachieBlinkLayer = 5;



        function init() {

            var startTime = Math.floor(new Date().getTime() / 1000);
            var CommentTimer = setInterval(CommentFunc, 500);

            function CommentFunc() {
                if (true) {
                    //XML読み込み
                    $(function () {
                        parse();
                        $("#select_game").change(function () {
                            var result = $(this).val();
                            parse(result);
                        });
                    });
                    function parse(type) {
                        $.ajax({
                            url: 'http://localhost/ignore/commentlog.xml',
                            type: 'GET',
                            dataType: 'xml',
                            cache: false,
                            timeout: 5000,
                            success: function (xml) {
                                xml = xml.getElementsByTagName('chat');
                                for (var i = 0; i < xml.length; i++) {
                                    if ((startTime < xml[i].getAttributeNode("date").value) ||
                                        ((startTime == xml[i].getAttributeNode("date").value) && (startNo < xml[i].getAttributeNode("no").value))) {
                                        startTime = xml[i].getAttributeNode("date").value;
                                        startNo = xml[i].getAttributeNode("no").value;
                                        var userId = xml[i].getAttributeNode("user_id").value;
                                        var comment = "";
                                        comment = xml[i].firstChild.nodeValue;
                                        //ニコ生のコメントからコマンド文字列を取得してcommand変数に格納
                                        var baseCommandStart = comment.indexOf("[");
                                        var baseCommandEnd = comment.indexOf("]");
                                        if ((baseCommandStart != -1) && (baseCommandEnd != -1)) {
                                            if (baseCommandEnd - baseCommandStart - 1 > 0) {
                                                var command = comment.substr(baseCommandStart + 1, baseCommandEnd - baseCommandStart - 1);
                                                var targetCanvas = document.getElementById(userId);
                                                //コマンドを受けてキャラ絵を操作
                                                if (command) {
                                                    //キャラ絵を退出させるコマンド
                                                    if (command == "logout") {
                                                        targetCanvas.remove();
                                                    }
                                                    //キャラ絵をまだ呼び出していない人
                                                    else if (!targetCanvas) {
                                                        var userCanvases = document.getElementById("UserCanvasWrapper").children;
                                                        var canvasCount = userCanvases.length;
                                                        // //user_canvasの属性data-positionの値から「存在しない数値かつ一番最小の数値」一つを見つけ出す
                                                        var availablePosition = minimumNumberDitect(userCanvases);
                                                        //キャラ絵最大表示数は6なのでそれ未満なら新規キャンバス生成
                                                        if (canvasCount < 6) {
                                                            targetCanvas = canvases.create(userId, availablePosition);
                                                            //commandからディレクトリ指定文字列を生成
                                                            var dataTargetDirectory = command.slice(0,command.length - 3) + "/" + command.slice(-3);
                                                            targetCanvas.setAttribute("data-targetDirectory", dataTargetDirectory);
                                                            fixedCommand = dataTargetDirectory + "/" + "000";
                                                            document.getElementById("UserCanvasWrapper").appendChild(targetCanvas);
                                                            userStage[userId] = new createjs.Stage(targetCanvas);
                                                            _tachieLoader[userStage[userId]] = new tachieLoader(fixedCommand, targetCanvas.width);
                                                            for (let index = 0; index < maxChildIndex - 1; index++) {
                                                                //この_emptyImgLoaderなぜかこのスコープ内で宣言ならmaxChildIndex回呼び出される上位で宣言すると1回のみ
                                                                var _emptyImgLoader = new tachieLoader("empty", targetCanvas.width);
                                                                userStage[userId].addChildAt(_emptyImgLoader.getSkinImage(targetCanvas.width),index);
                                                            }                                                            
                                                            userStage[userId].addChildAt(_tachieLoader[userStage[userId]].getSkinImage(targetCanvas.width),tachieBaseLayer);
                                                            successLoadingCheck_A(targetCanvas,userStage[userId],_tachieLoader[userStage[userId]]);
                                                        }
                                                    }
                                                    //キャラ絵を既に呼び出している人
                                                    else {
                                                        //表情差分指定コマンドは3桁の数字、それ以外はキャラ絵変更コマンドとみなす
                                                        if (Number(command) < 1000) {
                                                            var fixedCommand = targetCanvas.getAttribute("data-targetDirectory") + "/" + command;
                                                            _tachieLoader[userStage[userId]] = new tachieLoader(fixedCommand, targetCanvas.width);
                                                            userStage[userId].addChildAt(_tachieLoader[userStage[userId]].getSkinImage(),tachieEmotionLayer);
                                                            stageUpdate(userStage[userId]);
                                                            userStage[userId].removeChildAt(tachieEmotionLayer +1);
                                                            console.log(userStage[userId]);
                                                        }
                                                        else{
                                                            var targetStage = userStage[userId];
                                                            var dataTargetDirectory = command.slice(0,command.length - 3) + "/" + command.slice(-3);
                                                            fixedCommand = dataTargetDirectory + "/" + "000";
                                                            _tachieLoader[targetStage] = new tachieLoader(fixedCommand, targetCanvas.width);
                                                            targetStage.addChild(_tachieLoader[targetStage].getSkinImage(targetCanvas.width));
                                                            successLoadingCheck_B(targetCanvas,dataTargetDirectory,targetStage,_tachieLoader[targetStage]);
                                                            targetStage.removeChildAt(tachieBaseLayer + 1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        break;
                                    }
                                }
                            },
                            error: function () {
                                //commentxml書き込み中のロードは失敗することがある次の行を有効化するとロード失敗時に一時停止
                                //alert("dummycommentlog.xmlロード失敗");
                            }
                        });
                    }
                }
            }
            window.addEventListener("load", init);
        }

        function stageUpdate(targetStage){
            var tick = 0;
            var updateTick = createjs.Ticker.on("tick", function () {
                targetStage.update();
                tick += 1;
                if (tick > 48) {
                    createjs.Ticker.off("tick", updateTick);
                }
            })
        }

        function successLoadingCheck_A(canvas,targetStage,_tachieLoader){
            var tick = 0;
            var updateTick = createjs.Ticker.on("tick", function () {
                tick += 1;
                if (_tachieLoader.complete == true) {
                    targetStage.update();
                    createjs.Ticker.off("tick", updateTick);
                    return;
                }
                else if (tick > 49) {
                    createjs.Ticker.off("tick", updateTick);
                    canvas.remove();
                }
            })
        }

        function successLoadingCheck_B(canvas,dataTargetDirectory,targetStage,_tachieLoader){
            var tick = 0;
            var updateTick = createjs.Ticker.on("tick", function () {
                tick += 1;
                if (_tachieLoader.complete == true) {
                    createjs.Ticker.off("tick", updateTick);
                    canvas.setAttribute("data-targetDirectory", dataTargetDirectory);
                    let count = targetStage.numChildren;
                    for (let index = 0; index < count - 1 ; index++) {
                        targetStage.removeChildAt(0);  
                    }
                    for (let index = 0; index < maxChildIndex; index++) {
                        if (index < 2) {
                            var _emptyImgLoader = new tachieLoader("empty", canvas.width);
                            targetStage.addChildAt(_emptyImgLoader.getSkinImage(canvas.width),0); 
                        }
                        else if (index > 3) {
                            var _emptyImgLoader = new tachieLoader("empty", canvas.width);
                            targetStage.addChildAt(_emptyImgLoader.getSkinImage(canvas.width),3); 
                        }
                    }
                    targetStage.update();
                    createjs.Ticker.off("tick", updateTick);
                    return;
                }
                else if (tick > 49) {
                    createjs.Ticker.off("tick", updateTick);
                }
            })
        }

        function minimumNumberDitect (userCanvases){     
            var availablePosition = 0;       
            var array = [];
            for (var i = 0; i < 6; i++) {
                if (userCanvases[i]) {
                    array[i] = Number(userCanvases[i].getAttribute("data-position"));
                }
                else {
                    break;
                }
            }
            array.sort(function(a,b){
                    if( a < b ) return -1;
                    if( a > b ) return 1;
                    return 0;
            });
            for (let index = 0; index < array.length; index++) {
                if (array[index] != index) {
                    availablePosition = index;
                    break;
                }
                else{
                    ///////////////////////////////
                    //描画ポジションがおかしくなったらここ要注意
                    availablePosition = index + 1;
                    ///////////////////////////////
                    ///////////////////////////////
                }
            }
            return availablePosition;
        }
    </script>
</head>
<body onload="init();">
    <div id="UserCanvasWrapper">
    </div>
    <div id="another">
        <canvas id="otherCanvas5" width="50" height="0"></canvas>
    </div>
</body>
</html>